Project Requirements for Progressive Line
CAPTCHA
Introduction
Interactive CAPTCHAs verify that a user is human by asking them to perform a task that is simple for
humans but hard for bots. Traditional CAPTCHAs such as distorted text or image recognition are
increasingly ineffective as modern AI and computer‑vision models can solve them quickly 1 . Even
behaviour‑based CAPTCHAs that analyse mouse trajectories are threatened by tools like DMTG and
Ghost Cursor, which generate human‑like cursor movements 1 2 . Meanwhile, invisible CAPTCHAs like
Google’s reCAPTCHA v3 run risk analysis in the background, but they rely on extensive data collection and
can be bypassed by sophisticated bots 3 . There is a need for a novel CAPTCHA that combines interactivity
with resistance to AI mimicry while remaining user‑friendly.
The proposed progressive line CAPTCHA (sometimes called an ephemeral line CAPTCHA) addresses this need. It
asks the user to trace a hidden path that is revealed progressively as they move a pointer or finger. By
making the path invisible until touched and by fading it shortly afterwards, the challenge becomes a
moving target that cannot be solved using a single static image or recorded movement. This document
outlines the requirements and design guidelines for implementing such a CAPTCHA for a final‑year project
(FYP) with potential future commercialization.

Goals and Objectives
1. Novel Interaction: Design a CAPTCHA that requires users to trace a path that is revealed on the fly,
thereby combining visual perception and motor control in a way that is intuitive for humans and
challenging for bots.
2. AI Resistance: Incorporate procedural randomness and time sensitivity to hinder bots that rely on
screenshot analysis or human‑like cursor generation 4 1 .
3. User Experience: Ensure the task is quick, clear, and enjoyable. Line CAPTCHAs have been shown to
be easier for users than text CAPTCHAs, with over 80 % of first‑time users succeeding 5 . The
design should be accessible on both desktop (mouse/trackpad) and mobile (touch) devices.
4. Accessibility and Inclusion: Provide alternative verification methods (e.g., audio or simplified slider)
for users who cannot perform fine motor tasks, in line with accessibility concerns about
motor‑intensive CAPTCHAs 6 .
5. Evaluation and Research: Collect anonymized interaction metrics (success rate, time taken, path
deviation) to assess usability and security for the FYP. Use the findings to refine the design and to
justify its novelty compared to existing patents and commercial solutions.

1

Research Evidence and Justification
• Existing line CAPTCHAs: Prior work introduced line‑tracing CAPTCHAs where users drag along a
visible blurred or segmented line on a noisy background 5 . These designs are user‑friendly but are
static: once the line is displayed, an attacker could use image processing to detect it. Oracle’s patent
for a traceable image CAPTCHA instructs users to trace an outline composed of random strokes and
verifies the trace by comparing it with stored coordinates 7 . However, the line is fully visible at the
start and remains on screen.
• Progressive reveal mechanisms: A patent on progressive CAPTCHAs describes revealing characters
or images in pieces over time or requiring an interactive task before the challenge appears 8 .
Some commercial CAPTCHAs like scratch‑off puzzles reveal information gradually 9 . These show
that progressive disclosure can impede bots but have not been widely adopted.
• AI mimicry and behavioural analysis: Modern bots can generate realistic mouse trajectories using
diffusion models, reducing detection accuracy by 4.75–9.73 % 1 . Libraries like Ghost Cursor
replicate natural, curved and unpredictable mouse paths 2 . To resist such attacks, CAPTCHAs must
incorporate tasks that require real‑time visual feedback rather than pre‑computed motion.
• Security vs usability trade‑offs: Slider and drag CAPTCHAs are intuitive and widely used but rely on
behaviour analysis that can be bypassed if bots can mimic human movement 10 4 . Invisible
solutions like reCAPTCHA v3 and Cloudflare Turnstile minimise user friction by analysing background
signals 3 11 , yet they may collect more data and are not foolproof. A progressive line CAPTCHA
offers a balanced alternative: explicit user interaction with potential to combine behavioural analysis,
but without revealing the full challenge.
• Novelty: No public system combines a hidden path that is revealed only as the user moves with
immediate fading. Line CAPTCHAs exist 5 , and patents cover traceable images 7 and progressive
disclosure 8 , but the proposed combination appears unique. This uniqueness should be
emphasised when assessing patent risks and commercial potential.

Functional Requirements
1. Path Generation and Structure
• Randomised Path Creation: For each challenge, generate a unique path composed of Bézier curves
or smooth cubic splines. Randomise the number of segments (e.g., 6–12) and their curvature while
ensuring the path remains continuous and non‑intersecting. Avoid predictable patterns to prevent
bots from learning typical shapes. Prior research on line CAPTCHAs used cubic curves stored in
memory 12 ; this implementation should similarly store reference points for verification.
• Length and Complexity: The path length should be sufficient to capture meaningful behavioural
data but not so long as to frustrate users. A typical path length might span 25–50 % of the canvas
width/height (e.g., 400–800 pixels on desktop, scaled down on mobile). Include a mix of straight and
curved segments; avoid extremely tight corners that may be hard to follow on touch screens.
• Thickness and Visibility: Define an invisible centreline and a virtual “tunnel” around it. When the
user traces the path, reveal a visible coloured line slightly wider than the tunnel (e.g., 10 pixels thick)
to guide them. The hidden tunnel width (tolerance) can be narrower (e.g., ±5 pixels) to allow minor
deviations while rejecting gross errors.

2

2. Dynamic Reveal and Ephemerality
• Progressive Appearance: Initially, only show a start marker (e.g., a small circle) indicating where to
begin. As the user moves along the correct path, reveal the line ahead of the pointer/finger by a
fixed look‑ahead distance (e.g., 30–50 pixels) so the user sees the upcoming segment. Optionally
reveal a faint “ghost” of the target path behind the pointer to provide context.
• Fading Trail: Segments the user has passed should fade or disappear after a short time (e.g., 1–
2 seconds). This prevents attackers from reconstructing the full path by slowly moving and capturing
screen frames. The fading duration should be long enough to prevent confusion but short enough to
thwart screenshot‑based solutions.
• Time Limit: Impose an overall time‑to‑live (TTL) for the challenge (e.g., 15–20 seconds). If the user
takes too long, reset with a new path. This prevents bots from slowly sampling the path while still
giving legitimate users ample time.

3. Interaction and Input Handling
• Cross‑Platform Support: Support both mouse/trackpad (desktop) and touch/stylus (mobile) inputs.
Detect the input method and adjust path width and tolerance accordingly. On mobile, increase the
line and tunnel thickness to accommodate finger imprecision.
• Continuous Drawing: Require users to maintain contact (mouse button down or finger on screen)
while tracing. If they release prematurely, allow a limited number of retries (e.g., 1–2) before failing.
Provide clear instructions: “Press or touch the start point and follow the line as it appears. Do not lift
your finger/mouse.”
• Start and End Markers: Display a clear start indicator and finish indicator. Only reveal the finish
indicator when the user is close to the end; this prevents bots from simply moving directly to the end
without following the path.

4. Verification and Tolerance Thresholds
• Position Deviation: Capture the user’s pointer coordinates at a high sampling rate (e.g., 60 Hz).
Compare the path of these coordinates to the reference path using Euclidean distance. Define a
maximum allowed deviation (e.g., 5 pixels) for at least 90 % of the sampled points. If the user strays
outside the tunnel for more than a short threshold (e.g., 200 ms), the challenge fails.
• Speed Profile: Compute the user’s velocity along the path. Humans naturally vary speed (speed up
on straights, slow down on curves), whereas bots may move at a constant speed or unnatural jerk
patterns. Record metrics like mean velocity, acceleration variance, and micro‑hesitations. Use these
to distinguish human input 4 .
• Completion Time: Record the total time taken to complete the path. Humans will typically finish
within 3–8 seconds. Extremely fast completions (e.g., < 1 second) or extremely slow ones (exceeding
the TTL) can indicate automated attempts.
• Failure Handling: If a user fails (e.g., goes outside the tunnel, times out, or exhibits suspicious
behaviour), generate a new random path. Offer a limited number of attempts (e.g., 3) before falling
back to another CAPTCHA method or requiring additional verification.

5. Procedural Variation and Adaptive Difficulty
• Random Noise and Decoys: Although the path itself is hidden, additional distractor elements (e.g.,
faint random lines or shapes that appear briefly elsewhere on the canvas) can be generated to

3

distract bots that rely on simple heuristics. Ensure these decoys are subtle enough not to confuse
users.
• Adaptive Complexity: Incorporate an adaptive mechanism based on the perceived risk level (similar
to reCAPTCHA’s risk scoring 3 ). For low‑risk interactions, present shorter and simpler paths. For
higher‑risk interactions (e.g., suspicious behaviour, repeated failures), generate longer or more
complex paths, or adjust the tolerance thresholds.

6. Accessibility and Fallback
• Alternative Challenges: Because CAPTCHAs involving motor control can exclude users with tremors
or disabilities 6 , provide an alternative verification method such as an audio challenge or a
standard slider puzzle. Detect user preference or allow manual selection of an alternative.
• Instructions and Feedback: Present concise instructions with icons or animations showing how to
trace the line. Use high‑contrast colours for the revealed line and start/end markers. If the user fails,
explain why (e.g., “You strayed too far from the line”) and offer a retry.

Non‑Functional Requirements
1. Security and AI Resistance
• Ephemerality: Ensure the full path is never displayed all at once. Only the portion near the user’s
pointer should be visible, and it should fade quickly. This reduces the risk of bots using static image
processing to detect the path.
• Procedural Randomness: Use a secure random number generator to create paths and decoy
elements. Avoid repeating patterns across sessions. Do not store generated paths beyond the
current session.
• Behavioural Analysis: Collect behavioural metrics (speed variations, jitter, pauses) and feed them
into a classifier to distinguish human and bot interactions. Combine this with path adherence to
strengthen detection 4 .
• Data Privacy: Store only aggregated or hashed behavioural data needed for risk scoring. Do not use
cookies or cross‑site tracking to reduce privacy concerns, taking cues from Cloudflare Turnstile’s
minimal data usage 11 .

2. Usability
• Completion Time: Design the path so that legitimate users can finish quickly (ideally under
10 seconds). Avoid excessively long or intricate shapes that could cause frustration.
• Visual Design: Use smooth animations and clear colours for the line. Consider providing a subtle
haptic or sound feedback on mobile devices when the user is on the correct path.
• Cross‑Platform Consistency: Ensure the CAPTCHA performs consistently across modern browsers
and devices. Use HTML5 Canvas with fallback to SVG if needed. Detect high‑DPI screens and scale
the path appropriately.
• Retry Experience: Limit the number of times the user must attempt the CAPTCHA. Provide
immediate feedback on success or failure and do not require reloading the page.

4

3. Accessibility
• Alternative Text and Audio: For users with visual impairments, provide a text or audio alternative
that does not rely on tracing. Offer keyboard navigation to select an alternative.
• Motor Accessibility: Allow larger tolerance bands or simplified paths for users on devices with poor
pointing precision. Provide a toggle for a “high‑contrast mode” or “slow mode” that extends the TTL
and reduces complexity.

4. Legal and Patent Considerations
• Patent Landscape: Existing patents cover static line tracing and progressive CAPTCHAs 7 8 . To
avoid infringement, emphasise that the path is hidden until traced and fades immediately, which
differs from showing a visible image and instructing the user to trace it. Consult legal counsel before
commercial deployment.
• Compliance: Ensure the CAPTCHA complies with privacy regulations (e.g., GDPR) by minimising data
collection. Provide a clear privacy notice explaining what interaction data is recorded and how it is
used.

Implementation Guidance
1. Technology Stack: Implement the CAPTCHA using JavaScript and HTML5 Canvas to draw and
animate the path. Use CSS for styling and ensure the component can be embedded as an iframe or a
modular JavaScript library.
2. Path Data Structure: Represent the generated path as an array of control points with precomputed
sample points along the curve. Create a second array representing the tolerance “tunnel.”
3. Rendering Loop: On each animation frame, compute the segment of the path to reveal based on
the user’s current position. Draw only that segment, with fade‑out logic for previously revealed
segments. Use requestAnimationFrame for smooth animation.
4. Event Handling: Register pointerdown, pointermove, and pointerup events. On pointerdown, verify
that the pointer is within the start zone; on pointermove, update the user’s trace, reveal the line
ahead and record metrics; on pointerup, check if the finish zone has been reached and evaluate the
trace.
5. Evaluation Algorithm: After pointerup or TTL expiration, calculate the deviation metrics and speed
profile. Determine success or failure based on the thresholds described above. If successful, emit a
token or pass the user; if not, reset the challenge.
6. Integration: Provide API hooks to start the challenge, report results, and handle fallback options.
Offer a callback or promise that resolves when the user completes the CAPTCHA, allowing
integration with existing form workflows.
7. Logging for FYP: Record anonymized metrics such as number of attempts, success/fail, average
deviation, and completion time. Store these in a secure database for analysis. Use these data to
evaluate security (e.g., resistance to automated attacks) and usability (e.g., average completion
times) during the FYP.

Conclusion and Next Steps
The progressive line CAPTCHA seeks to provide a fresh defence against bots by requiring users to follow a
line that appears only under their pointer. This approach builds on earlier work on line tracing and
progressive disclosure but introduces ephemerality and real‑time guidance to increase security while

5

remaining intuitive for humans. Implementing this CAPTCHA entails careful tuning of path complexity,
tolerance thresholds, and user guidance. The success of the project will depend on evaluating both security
(resistance to AI‑generated cursor movement) and usability (completion rates and user satisfaction). Future
work should include testing across diverse devices, analysing collected interaction data, refining
behavioural classifiers, and exploring legal considerations for commercial use.

References
The following sources informed these requirements:
• Studies on the susceptibility of CAPTCHAs to human‑like cursor generation, highlighting the need for
more complex interactions 1 2 .
• Research on user‑friendly line CAPTCHAs and the advantages and limitations of static line tracing 5
12 .
• Patent descriptions of traceable image CAPTCHAs and progressive CAPTCHAs, which show existing
approaches and inform our differentiation 7 8 .
• Discussions on slider and drag CAPTCHAs, user frustration, and behavioural analysis 10 4 .
• Articles on accessibility concerns related to motor‑intensive CAPTCHAs 6 .
• Blog posts on reCAPTCHA v3 and Cloudflare Turnstile, illustrating trends towards background risk
analysis and data privacy considerations 3 11 .

1

DMTG: A Human-Like Mouse Trajectory Generation Bot Based on Entropy-Controlled Diffusion Networks

https://arxiv.org/html/2410.18233v1
2

How to Use Ghost Cursor for Web Scraping - ZenRows

https://www.zenrows.com/blog/ghost-cursor

Introducing reCAPTCHA v3: the new way to stop bots | Google Search Central Blog | Google for
Developers
3

https://developers.google.com/search/blog/2018/10/introducing-recaptcha-v3-new-way-to
4

CAPTCHA Hacking Landscape in 2023: An Updated Analysis

https://www.geetest.com/en/article/captcha-hacking-landscape-in-2023
5

12

(PDF) User friendly line CAPTCHAs

https://www.researchgate.net/publication/224124170_User_friendly_line_CAPTCHAs
6

The Accessibility Problem With Authentication Methods Like CAPTCHA — Smashing Magazine

https://www.smashingmagazine.com/2025/11/accessibility-problem-authentication-methods-captcha/
7

US9471767B2 - CAPTCHA techniques utilizing traceable images - Google Patents

https://patents.google.com/patent/US9471767B2/en
8

9

US20090113294A1 - Progressive captcha - Google Patents

https://patents.google.com/patent/US20090113294A1/en
10

Slider CAPTCHA: Top Tool You Need Now

https://www.geetest.com/en/article/slider-CAPTCHA-top-tool-for-security-and-usability
11

Announcing Turnstile, a user-friendly, privacy-preserving alternative to CAPTCHA

https://blog.cloudflare.com/turnstile-private-captcha-alternative/

6

